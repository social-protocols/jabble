generator client {
  provider        = "prisma-client-js"
  previewFeatures = ["views"]
}

generator kysely {
  provider = "prisma-kysely"

  // Optionally provide a destination directory for the generated file
  // and a filename of your choice
  output          = "../app/db"
  fileName        = "kysely-types.ts"
  // Optionally generate runtime enums to a separate file
  enumFileName    = "kysely-enums.ts"
  previewFeatures = ["views"]
}

datasource db {
  provider = "sqlite"
  url      = env("DATABASE_URL")
}

model User {
  id       String  @id @default(cuid())
  email    String  @unique
  username String  @unique
  name     String?

  createdAt DateTime @default(now())
  // updatedAt DateTime @updatedAt

  image    UserImage?
  password Password?
  sessions Session[]

  posts       Post[]
  voteHistory VoteHistory[]
  roles       Role[]
}

model UserImage {
  id          String  @id @default(cuid())
  altText     String?
  contentType String
  blob        Bytes

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  userId String @unique
}

model Password {
  hash   String
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  userId String @unique
}

model Session {
  id             String   @id @default(cuid())
  expirationDate DateTime
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt

  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  userId String

  // non-unique foreign key
  @@index([userId])
}

model Permission {
  id          String @id @default(cuid())
  action      String // e.g. create, read, update, delete
  entity      String // e.g. note, user, etc.
  access      String // e.g. own or any
  description String @default("")

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  roles Role[]

  @@unique([action, entity, access])
}

model Role {
  id          String @id @default(cuid())
  name        String @unique
  description String @default("")

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  users       User[]
  permissions Permission[]
}

model Verification {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())

  /// The type of verification, e.g. "email" or "phone"
  type String

  /// The thing we're trying to verify, e.g. a user's email or phone number
  target String

  /// The secret key used to generate the otp
  secret String

  /// The algorithm used to generate the otp
  algorithm String

  /// The number of digits in the otp
  digits Int

  /// The number of seconds the otp is valid for
  period Int

  /// The valid characters for the otp
  charSet String

  /// When it's safe to delete this verification
  expiresAt DateTime?

  @@unique([target, type])
}

model Post {
  id        Int      @id @default(autoincrement())
  parentId  Int?
  content   String
  authorId  String
  createdAt DateTime @default(now())
  parent    Post?    @relation("post_notes", fields: [parentId], references: [id], onDelete: NoAction, onUpdate: NoAction)
  notes     Post[]   @relation("post_notes")
  user      User     @relation(fields: [authorId], references: [id], onDelete: NoAction, onUpdate: NoAction)
}

model Tag {
  id          Int           @id @default(autoincrement())
  tag         String        @unique
  VoteHistory VoteHistory[]
  TagStats    TagStats?
}

model VoteHistory {
  rowid     Int      @id @default(autoincrement())
  userId    String
  tagId     Int
  postId    Int
  noteId    Int?
  direction Int
  createdAt DateTime @default(now())
  user      User     @relation(fields: [userId], references: [id], onDelete: NoAction, onUpdate: NoAction)
  tag       Tag      @relation(fields: [tagId], references: [id], onDelete: NoAction, onUpdate: NoAction)

  @@index([userId, tagId, postId])
}

model PostStats {
  tagId     Int
  postId    Int
  // updatedAt DateTime
  attention Int
  views     Int
  // uniqueUsers String

  @@unique([postId])
}

model LocationStats {
  locationType        Int
  oneBasedRank        Int
  voteShare           Int
  latestSitewideVotes Int

  @@unique([locationType, oneBasedRank])
}

model TagStats {
  tagId        Int @unique
  views        Int
  // votes    Int
  votesPerView Int

  tag Tag @relation(fields: [tagId], references: [id], onDelete: Cascade, onUpdate: Cascade)
}

model ExplorationStats {
  rowid Int @id @default(autoincrement())
  // views Int
  votes Int
}

view DetailedTally {
  tagId                      Int
  postId                     Int
  noteId                     Int
  countGivenShownThisNote    Int
  totalGivenShownThisNote    Int
  countGivenNotShownThisNote Int
  totalGivenNotShownThisNote Int
  // count_for_note Int
  // total_for_note Int

  @@unique([tagId, postId, noteId])
}


view CurrentInformedTally {
  tagId  Int
  postId Int
  noteId Int
  count  Int
  total  Int

  @@unique([tagId, postId, noteId])
}

view CurrentTally {
  tagId  Int
  postId Int
  count  Int
  total  Int

  @@unique([tagId, postId])
}

view CurrentVote {
  userId    String
  tagId     Int
  postId    Int
  direction Int
  latest    Int
  createdAt DateTime

  @@unique([userId, tagId, postId])
}


